#!/usr/bin/env bash
##------------------------------------------------------------------------------
##==============================================================================
##     Lux CLI  > lux watch 2 > lux.out  2>&1
##       __
##       \ \
##        \ \
##         > \
##        / ^ \
##       /_/ \_\
##
##  QodeParty (c) 2018
##==============================================================================
	readonly script_pid=$$
	readonly script_author="qodeninja"
	readonly script_id="lux"
	readonly script_prefix="LUX"
	readonly script_rc_file=".luxrc"
	readonly script_log_file="$script_id.log"
	readonly script_lic="MIT License"
					 script_entry="$0"
	function include(){
		source "${@}"
	}
##--save me
	CPID="$$"
	BIN_DIR="$( cd "$(dirname "$0")"   || exit; pwd)"
	THIS_DIR="$( cd $BIN_DIR && cd ..  || exit; pwd)"
	ROOT_DIR="$( cd $THIS_DIR && cd .. || exit; pwd)"
	opt_verbose=0
	opt_no_comments=1
	opt_skip_input=1
	opt_dev_mode=1
	missing=()
	__repo_list=( )
	__alias_list=( )
##==============================================================================
## import file:inc-vars ##
##==============================================================================
	LUX_RC="$HOME/.luxrc"
	LUX_ID="$script_id"
	LUX_HOME= #${LUX_HOME:-$THIS_DIR}
	LUX_DEV_BIN="$BIN_DIR"
	LUX_BIN=
	LUX_SEARCH_PATH=
	LUX_WWW= #$( cd $THIS_DIR && cd ../lux-www; pwd -P )
	LUX_CLI=
	LUX_DEV=
	LUX_CSS=
	LUX_MODS=
	LUX_CLI_VARS=
	LUX_USER_CONF=
	JS_VAR_LOADER="load-vars.js"
	JS_CONF_LOADER="load-conf.js"
	BASH_RC="$HOME/.bashrc"
	[ -f "$HOME/.profile" ] && BASH_PROFILE="$HOME/.profile" || BASH_PROFILE="$HOME/.bash_profile"
	BASH_USR_BIN= #"$HOME/bin"
	if [ -n "$BASH_USR_BIN" ]; then
		QODEPARTY_INSTALL_DIR="$BASH_USR_BIN/qodeparty"
		LUX_INSTALL_DIR="$QODEPARTY_INSTALL_DIR/lux"
		LUX_INSTALL_BIN="$LUX_INSTALL_DIR/lux"
	fi
	[ -f "$LUX_RC" ] && source $LUX_RC || : # printf "Cant find Lux RC"
	if [ -n "$LUX_HOME" ]; then
		THIS_ROOT="$(dirname $LUX_HOME)"
		LUX_BUILD="$LUX_HOME/build"
		LUX_DIST="$LUX_HOME/dist"
		LUX_RES="$LUX_HOME/www/res"
		LUX_RBUILD="$LUX_RES/build"
		LUX_INST=1
		LUX_LIB="$LUX_HOME/src/lib"
		LUX_EXT="$LUX_LIB/plugin"
		LUX_DEFS="$LUX_LIB/defs"
		LUX_CORE="$LUX_HOME/src/styl/core"
		LUX_VARS="$LUX_HOME/src/styl/vars"
		LUX_UTIL="$LUX_HOME/src/styl/util"
		LUX_META_JS="$LUX_RES/js/lux-meta.js"
		OPT_INCLUDE="--include $LUX_EXT --include $LUX_UTIL --include $LUX_VARS --include $LUX_CORE"
		OPT_IMPORT="--import $LUX_UTIL --import $LUX_VARS " #order matters
		OPT_USE="" #update with lux_var_refresh
		OPT_ALL="" #update with lux_var_refresh
	else
		: #printf "Lux home not defined $LUX_HOME \n"
	fi
##==============================================================================
## import file:inc-term ##
##==============================================================================
##------------------------------------------------------------------------------
##==============================================================================
    red=$(tput setaf 1)
    red2=$(tput setaf 9)
    yellow=$(tput setaf 11)
    orange=$(tput setaf 214)
    green=$(tput setaf 2)
    blue=$(tput setaf 12)
    cyan=$(tput setaf 123)
    purple=$(tput setaf 213)
    grey=$(tput setaf 244)
    grey2=$(tput setaf 240)
    w=$(tput setaf 15)
    wz=$(tput setaf 248)
    lambda="\xCE\xBB"
    line="$(sed -n '2,2 p' $BASH_SOURCE)$nl"
    bline="$(sed -n '3,3 p' $BASH_SOURCE)$nl"
    x=$(tput sgr0)
    sp="   "
    tab=$'\t'
    nl=$'\n'
    diamond='\xE1\x9B\x9C'
    delim='\x01'
    delta="${orange}\xE2\x96\xB3"
    pass="${green}\xE2\x9C\x93"
    fail="${red}\xE2\x9C\x97$red2"
    dots='\xE2\x80\xA6'
    space='\x20'
    eol="$(tput el)"
    eos="$(tput ed)"
    cll="$(tput cuu 1 && tput el)"
    bld="$(tput bold)"
    rvm="$(tput rev)"
    opt_quiet=1
    opt_force=1
    opt_verbose=1
    opt_silly=1
    opt_debug=1
    opt_local_conf=1
    opt_basis=
    opt_dump_col="$orange"
    opt_dump=1
    [[ "${@}" =~ "--debug" ]] && opt_debug=0 || :
    [[ "${@}" =~ "--info"  ]] && opt_verbose=0 || :
    [[ "${@}" =~ "--silly" ]] && opt_silly=0 || :
    [[ "${@}" =~ "--quiet" ]] && opt_quiet=0 || :
    [[ "${@}" =~ "--force" ]] && opt_force=0 || :
    [[ "${@}" =~ "--dev"   ]] && opt_dev_mode=0 || :
    [[ "${@}" =~ "--local" ]] && opt_local_conf=0 || :
    [[ "${@}" =~ "--dump"  ]] && opt_dump=0  || :
    if [ $opt_quiet   -eq 1 ]; then
       [ $opt_silly   -eq 0 ] && opt_verbose=0
       [ $opt_verbose -eq 0 ] && opt_debug=0
    fi
    __buf_list=1
    function handle_sigint(){ s="$?"; kill 0; exit $s;  }
    function handle_sigtstp(){ kill -s SIGSTOP $$; }
    function handle_input(){ [ -t 0 ] && stty -echo -icanon time 0 min 0; }
    function cleanup(){ [ -t 0 ] && stty sane; }
    function fin(){
      local E="$?"
      cleanup
      [ $E -eq 0 ] && __print "${pass} ${green}${1:-Done}.${x}\n\n" \
                   || __print "$red$fail ${1:-${err:-Cancelled}}.${x}\n\n"
    }
    trap handle_sigint INT
    trap handle_sigtstp SIGTSTP
    trap handle_input CONT
    trap fin EXIT
    function __print(){
      local text color prefix
      text=${1:-}; color=${2:-grey}; prefix=${!3:-};
      [ $opt_quiet -eq 1 ] && [ -n "$text" ] && printf "${prefix}${!color}%b${x}\n" "${text}" 1>&2 || :
    }
    function __printf(){
      local text color prefix
      text=${1:-}; color=${2:-grey}; prefix=${!3:-};
      [ $opt_quiet -eq 1 ] && [ -n "$text" ] && printf "${prefix}${!color}%b${x}" "${text}" 1>&2 || :
    }
    function    info(){ local text=${1:-}; [ $opt_debug   -eq 0 ] && __print "$lambda$text" "blue"; }
    function   silly(){ local text=${1:-}; [ $opt_silly   -eq 0 ] && __print "$dots$text" "purple"; }
    function   trace(){ local text=${1:-}; [ $opt_verbose -eq 0 ] && __print "$text"   "grey2"; }
    function  ftrace(){ local text=${1:-}; [ $opt_verbose -eq 0 ] && __print " $text"   "fail"; }
    function  ptrace(){ local text=${1:-}; [ $opt_verbose -eq 0 ] && __print " $text$x" "pass"; }
    function  wtrace(){ local text=${1:-}; [ $opt_verbose -eq 0 ] && __print " $text$x" "delta"; }
    function  dtrace(){ local text=${1:-}; [ $opt_dev_mode -eq 0 ] && __print "##[ $text ]##"   "purple"; }
    function   error(){ local text=${1:-}; __print " $text" "fail"; }
    function    warn(){ local text=${1:-}; __print " $text$x" "delta";  }
    function    pass(){ local text=${1:-}; __print " $text$x" "pass"; }
    function success(){ local text=${1:-}; __print "\n$pass $1 [$2] \n$bline\n\n\n"; }
    function   fatal(){ trap - EXIT; __print "\n$fail $1 [$2] \n$bline\n\n\n"; exit 1; }
    function   quiet(){ [ -t 1 ] && opt_quiet=${1:-1} || opt_quiet=1; }
    function  status(){
      local ret res msg
      ret=$1; res=$2; msg=$3; __print "$res";
      [ $ret -eq 1 ] && fatal "Error: $msg, exiting" "1";
      return 0
    }
  function confirm() {
    local ret;ret=1
    __printf "${1}? > " "white" #:-Are you sure ?
    while read -r -n 1 -s answer; do
      if [[ $answer = [YyNn10tf+\-q] ]]; then
        [[ $answer = [Yyt1+] ]] && __printf "${bld}${green}yes${x}" && ret=0 || :
        [[ $answer = [Nnf0\-] ]] && __printf "${bld}${red}no${x}" && ret=1 || :
        [[ $answer = [q] ]] && __printf "\n" && exit 1 || :
        break
      fi
    done
    __printf "\n"
    return $ret
  }
  function prompt_path(){
    local res ret next
    prompt="$1"
    prompt_sure="$2"
    default="$3"
    prompt=$(eval echo "$prompt")
    while [[ -z "$next" ]]; do
      read -p "$prompt? > ${bld}${green}" __NEXT_DIR
      res=$(eval echo $__NEXT_DIR)
      [ -z "$res" ] && res="$default"
      if [ -n "$res" ]; then
        if [ "$res" = '?' ]; then
          echo "cancelled"
          return 1
        fi
        if confirm "${x}${prompt_sure} [ ${blue}$res${x} ] (y/n)"; then
          if [ ! -d "$res" ]; then
            error "Couldn't find the directory ($res). Try Again. Or '?' to cancel."
          else
            next=1
          fi
        fi
      else
        warn "Invalid Entry! Try Again."
      fi
    done
    echo "$res"
  }
  function dump(){
    local len arr i this flag newl
    arr=("${@}"); len=${#arr[@]}
    [ $__buf_list -eq 0 ] && flag="\r" &&  newl="$eol" || newl="\n"
    if [ $len -gt 0 ]; then
      handle_input
      for i in ${!arr[@]}; do
        this="${arr[$i]}"
        [ -n "$this" ] && printf -v "out" "$flag$opt_dump_col$dots(%02d of %02d) $this $x" "$i" "$len"
        trace "$out"
        sleep 0.05
      done
      cleanup
      printf -v "out" "$flag$green$pass (%02d of %02d) Read. $x$eol" "$len" "$len"
      trace "$out"
    fi
  }
  [ $opt_dev_mode -eq 0 ] && dtrace "DEV MODE ENABLED"
##==============================================================================
## import file:inc-doc ##
##==============================================================================
	function lux_usage_sh(){
		local data
		data="$(cat <<-EOF
			${n}${x}${grey}
			Usage: lux cmd [cmd, ...] --info --debug
			try lux help to get a list of commands
			${x}
		EOF
		)";
		__print "$data"
	}
	function lux_usage(){
		local b y g n t p data;
		b=$blue;y=$orange;g=$green;p=$cyan;v=$purple;
		s=$sp;t=$tab;n=$nl;sc='';
		data="$(cat <<-EOF
			${b}${blambda}${x}
			${b}${line//#/}
			${n}${n}
			${s}${b}${lambda}Lux Command Line Tool v$script_vers${x}
			${s}${b}User NPM Commands${x}${n}
			${s}${p}npm run make${x}  npm wrapper for ${y}lux make${x}
			${s}${p}npm run clean${x} npm wrapper for ${y}lux clean${x}
			${s}${b}Install Commands${x}${n}
			${s}${p}${sc} check  ${x}${t}   verify install and related repos
			${s}${p}${sc} repair ${x}${t}   attempt to fix any install problems
			${s}${p}${sc} link   ${x}${t}   makes lux-cli available on command line
			${s}${p}${sc} unlink ${x}${t}   remove lux-cli from command line
			${s}${p}${sc} rc     ${x}${t}   dump .luxrc file to screen
			${s}${p}${sc} rrc    ${x}${t}   regenerate .luxrc file with current vars
			${s}${b}Build Commands${x}${n}
			${s}${p}${sc} make   ${x}${t}   generate lux.css and lux.min.css dist
			${s}${p}${sc} clean  ${x}${t}   clean all generated dirs and files
			${s}${p}${sc} find ${y}[html]${x}${t}   grep local html,styl and css files
			${s}${p}${sc} res    ${x}${t}   copy build to dev/res for testing
			${s}${p}${sc} each   ${x}${t}   generate lux sub module files for testing
			${s}${p}${sc} all    ${x}${t}   generate lux module files for testing
			${s}${p}${sc} watch ${y}[t]${x}${t}   watch dev files for changes every [${y}t-seconds${x}]
			${s}${b}Info Commands${x}${n}
			${s}${p}${sc} home   ${x}${t}   output lux home path for use in scripts
			${s}${p}${sc} bin    ${x}${t}   output lux bin path for use in scripts
			${s}${p}${sc} mods   ${x}${t}   output lux style mods
			${s}${p}${sc} vars   ${x}${t}   output lux variables
			${s}${p}${sc} help   ${x}${t}   output this page
			${s}${b}Flags${x}${n}
			${s}${p}${sc} --debug${x}${t}   enable debug mode
			${s}${p}${sc} --info ${x}${t}   enable verbose output
			${s}${p}${sc} --dump${x}${t}    enable dump to screen mode
			${s}${p}${sc} --lang ${x}${t}   translate class and ids for specified lang
			${s}${p}${sc} --12/16${x}${t}   set grid basis to basis-12 or basis-16
			${s}${b}Dev Commands${x}${n}
			${s}${p}${sc} cdist    ${x}${t}   generate cli executable in ${v}\$LUX_CLI/dist${x}
			${s}${p}${sc} cpub     ${x}${t}   publish lux binary to ${v}\$LUX_BIN${x} dir
			${s}${p}${sc} fc       ${x}${t}   dev fast nuke requires --dev flag
			${LUX_INST}
			${b}${line//#/}${x}
		EOF
		)";
		__print "$data"
		[ -e $LUX_INST ] && warn "Lux isnt configured fully" || :
	}
	function lux_vars(){
		local data b w g p y s t n;
		b=$blue;w=$wz;g=$grey2;p=$cyan;y=$orange;
		s=$sp;s2=$sp$sp;t=$tab;n=$nl;
		data="$(cat <<-EOF
			$line
			${s2}${b}USR_CONF   = ${yellow}${LUX_USER_CONF//$THIS_ROOT/.}
			${s2}${b}LUX_ID     = ${w}$LUX_ID
			${s2}${b}LUX_RC     = ${w}$LUX_RC
			${s2}${p}THIS_ROOT  = ${w}$THIS_ROOT
			${s2}${p}THIS_DIR   = ${w}$THIS_DIR
			${s2}${p}BIN_DIR    = ${w}$BIN_DIR
			${s2}${b}LUX_MODS   = ${y}${LUX_MODS[*]}${x}
			${s}---------------------------------
			${s}Repos
			${s2}${b}LUX_SEARCH_PATH = ${w}$LUX_SEARCH_PATH
			${s2}${b}LUX_WWW    = ${y}$LUX_WWW
			${s2}${b}LUX_CLI    = ${y}$LUX_CLI
			${s2}${b}LUX_DEV    = ${y}$LUX_DEV
			${s2}${b}LUX_CSS    = ${y}$LUX_CSS${x}
			${s}---------------------------------
			${s}Main
			${s2}${b}LUX_HOME   = ${w}${LUX_HOME}
			${s}---------------------------------
			${s}Derived
			${s2}${b}LUX_BIN    = ${w}${LUX_BIN//$LUX_HOME/.}
			${s2}${b}LUX_CORE   = ${w}${LUX_CORE//$LUX_HOME/.}
			${s2}${b}LUX_VARS   = ${w}${LUX_VARS//$LUX_HOME/.}
			${s2}${b}LUX_UTIL   = ${w}${LUX_UTIL//$LUX_HOME/.}
			${s2}${b}LUX_DIST   = ${w}${LUX_DIST//$LUX_HOME/.}
			${s2}${b}LUX_BUILD  = ${w}${LUX_BUILD//$LUX_HOME/.}
			${s2}${b}LUX_RES    = ${w}${LUX_RES//$LUX_HOME/.}
			${s2}${b}LUX_RBUILD = ${w}${LUX_RBUILD//$LUX_HOME/.}
			${s2}${b}LUX_LIB    = ${w}${LUX_LIB//$LUX_HOME/.}
			${s2}${b}LUX_EXT    = ${w}${LUX_EXT//$LUX_HOME/.}
			${s2}${b}LUX_DEFS   = ${w}${LUX_DEFS//$LUX_HOME/.}
			${s}#--------------------------------
			${x}
			$line
		EOF
		)";
		__print "$data"
	}
##==============================================================================
## import file:inc-utils ##
##==============================================================================
	function require_entry(){
		if [[ ! "$script_entry" =~ "luxbin" ]]; then
			error "$1"
			exit 1
		fi
	}
	function require_dev(){
		if [[ ! "$LUX_DEVELOPER" -eq 0 ]]; then
			error "$1"
			exit 1
		fi
	}
	function in_string(){ [ -z "${2##*$1*}" ]; }
  function escape_sed_regex(){
  	sed -e 's/[]\/$*.^[]/\\&/g' <<< "$1"
	}
  function quoteRe() { sed -e 's/[^^]/[&]/g; s/\^/\\^/g; $!a\'$'\n''\\n' <<<"$1" | tr -d '\n'; }
	function insert_where(){ insert="$1" ; into="$2" ; where="$3" ; sed -e "/\s*${where}/r ${insert}" "$into" ; }
	function insert_wh_replace () {
		tmp=$(mktemp) ;
		insert_where "$@" > "$tmp" ;
		mv "$tmp" "$2" ;
	}
	function insert_at(){ insert="$1" ; into="$2" ; at="$3" ; sed -e "${at}r ${insert}" "$into" ; }
	function insert_at_replace(){ tmp=$(mktemp) ; insert_at "$@" > "$tmp" ; mv "$tmp" "$2" ; }
	function in_array(){
		local e
		for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done
		return 1
	}
  function indexof(){
    local elem args i j list; elem=$1; shift; list=("${@}")
    i=-1;
    for ((j=0;j<${#list[@]};j++)); do
      [ "${list[$j]}" = "$elem" ] && { i=$j; break; }
    done;
    echo $i;
    [[ "$i" == "-1" ]] && return 1 || return 0
  }
	function waitkey(){
		local n l;n=0
		while test $n -lt 3; do
			read l
			sleep 0.2
			echo -n " "
			n=$[n+1]
		done
		printf "$x"
		printf "\r$green$pass Done. $x$eol\n"
		clear
	}
	function join_by(){
		local IFS="$1"; shift;
		echo "$*";
	}
	function pop_array(){
		local match="$1"; shift
		local temp=()
		local array=($@)
		for val in "${array[@]}"; do
		    [[ ! "$val" =~ "$match" ]] && temp+=($val)
		done
		array=("${temp[@]}")
		unset temp
		echo "${array[*]}"
	}
	function upd_array(){
		local val="$1"; shift;
		local list=($@)
		local id="${val:1}"
		local list2="$(join_by \| ${list[@]})"
		local xfound=
		case "|$list2|" in
			*"|$id|"*) xfound=0;;
			*) xfound=1;;
		esac
		##trace "$val"
		if [[ "$val" =~ ^-.*  ]]; then
			[ $xfound -eq 0 ] && list=($(pop_array "$id" "${list[@]}"))
		elif [[ "$val" =~ ^\+.* ]]; then
			[ $xfound -eq 1 ] && list+=($id)
		elif [[ "$val" =~ ^\?.* ]]; then
			[ $xfound -eq 1 ] && list+=($id) || list=($(pop_array "$id" "${list[@]}"))
		else
			__print "Invalid ($val) missing (+ add - rem ? toggle )"
			return 1
		fi
		val="${list[*]}"
		echo "$val"
		return 0
	}
	function add_var(){
		local list=($@)
		ptrace "Adding Vars ${list[*]}"
		for i in ${!list[@]}; do
			this="+${list[$i]}"
			LUX_CLI_VARS=$(upd_array $this ${LUX_CLI_VARS[@]})
		done
	}
	function sub_dirs(){
		local path=$1
		res=($(find "$path" -type d -printf '%P\n' ))
		echo "${res[*]}"
	}
	function json_maker(){
		vars=( ${LUX_CLI_VARS[@]} ${@})
		str=""
		len=$((${#vars[@]}-1));
		for i in ${!vars[@]}; do
			this="${vars[$i]}"
			this_var="${this#*:}"
			this=${this%%:*}
			printf -v "this" '%s:\"%s\"' "lux_$this" $this_var
			[ $i -lt $len ] && this="${this},"
			str="$str$this"
		done
		printf -v "str" "{%s}" $str #stylus is picky about json format
		echo "$str"
	}
##==============================================================================
## import file:inc-filetools ##
##==============================================================================
	function find_dirs(){
		info "Finding repo folders..."
		warn "This may take a few seconds..."
		find_cmd="find ${2:-.} -mindepth 1"
		[[ $1 =~ "1" ]] && find_cmd+=" -maxdepth 2" || :
		[[ $1 =~ git ]] && find_cmd+=" -name .git"  || :
		find_cmd+=" -type d ! -path ."
		awk_cmd="awk -F'.git' '{ sub (\"^./\", \"\", \$1); print \$1 }'"
		cmd="$find_cmd | $awk_cmd"
		eval "$cmd" #TODO:check if theres a better way to do this
	}
	function file_marker(){
		local delim dst dend mode lbl
		mode="$1"
		lbl="$2"
		delim="$3"
		dst='#'; dend='#';
		[ "$delim" = "js" ] && dst='\/\*'; dend='\*\/' || :
		if [ "$mode" = "str" ]; then
			str="${dst}----${block_lbl}:str----${dend}"
		else
			str="${dst}----${block_lbl}:end----${dend}"
		fi
		echo "$str"
	}
	function file_add_block(){
		local newval src block_lbl match_st match_end data res ret
		newval="$1"; src="$2"; block_lbl="$3"; delim="$4"; ret=1;
		match_st=$(file_marker "str" "${block_lbl}" "${delim}" )
		match_end=$(file_marker "end" "${block_lbl}" "${delim}" )
		res=$(file_find_block "$src" "$block_lbl" "${delim}" )
		ret=$?
		if [ $ret -gt 0 ]; then #nomatch
			data="$(cat <<-EOF
				${match_st}
				${newval}
				${match_end}
			EOF
			)";
			echo "$data" >> $src
			ret=$?
		fi
		return $ret
	}
	function file_del_block(){
		local src block_lbl match_st match_end data res ret dst dend
		src="$1"
		block_lbl="$2"
		delim="$3";
		match_st=$(file_marker "str" "${block_lbl}" "${delim}" )
		match_end=$(file_marker "end" "${block_lbl}" "${delim}" )
		sed -i.bak "/${match_st}/,/${match_end}/d" "$src" #this works on ubuntu
		ret=$?
		res=$(file_find_block "$src" "$block_lbl" "${delim}" )
		ret=$?
		[ $ret -gt 0 ] && ret=0 || ret=1
		rm -f "${src}.bak"
		return $ret
	}
	function file_find_block(){
		local src block_lbl match_st match_end data res ret
		src="$1"; block_lbl="$2"; delim="$3"; ret=1
		match_st=$(file_marker "str" "${block_lbl}" "${delim}")
		match_end=$(file_marker "end" "${block_lbl}" "${delim}")
		res=$(sed -n "/${match_st}/,/${match_end}/p" "$src")
		[ -z "$res" ] && ret=1 || ret=0;
		echo "$res"
		return $ret;
	}
	function profile_link(){
		local ret res data
		[ ! -f "$LUX_RC" ] && lux_make_rc || :
		if [ -f "$LUX_RC" ]; then
			src="$BASH_PROFILE" #link to bashrc so vars are available to subshells?
			[ ! -f "$src" ] && touch "$src"
			lbl="$script_id"
			res=$(file_find_block "$src" "$lbl" ); ret=$?
			if [ $ret -eq 1 ]; then
				data="$(cat <<-EOF
					${tab} if [ -f "$LUX_RC" ] ; then
					${tab}   source "$LUX_RC"
					${tab} else
					${tab}   [ -t 1 ] && echo "\$(tput setaf 214).luxrc is missing, lux link or unlink to fix ${x}" ||:
					${tab} fi
				EOF
				)";
				res=$(file_add_block "$data" "$src" "$lbl" )
				ret=$?
			fi
		else
			error "Profile doesnt exist @ $BASH_PROFILE"
		fi
	}
	function profile_unlink(){
		local ret res data src lbl
		src="$BASH_RC"
		lbl="$LUX_ID"
		[ -f "$LUX_RC" ] && rm -f "$LUX_RC"
		res=$(file_del_block "$src" "$lbl" )
		ret=$?
		[ $ret -eq 0 ] && __print ".luxrc removed from $BASH_RC" "red" ||:
	}
##==============================================================================
## import file:inc-meta ##
##==============================================================================
	[ $opt_dev_mode -eq 0 ] && LUX_RC="./.luxrc" || :
	function lux_var_refresh(){
		trace "lux vars call"
		if [ -d "$LUX_HOME" ]; then
			lux_gen_load
			add_var "build:$script_build" "vers:$script_vers" "branch:$script_branch"
			OPT_USE="--use $LUX_EXT/$JS_VAR_LOADER --with $(json_maker)"
			[ -f "$LUX_USER_CONF" ] && OPT_USE="$OPT_USE --use $LUX_EXT/$JS_CONF_LOADER" || :
			OPT_ALL="$OPT_USE $OPT_IMPORT $OPT_INCLUDE"
			lux_mods
		fi
	}
	function lux_gen_version(){
		src="${1:-$LUX_HOME}"
		dest="$src/build.id"
		trace "Generating build information from Git... ($src)"
		bvers="$(cd $src;git describe --abbrev=0 --tags)"
		binc="$(cd $src;git rev-list HEAD --count)"
		branch="$(cd $src;git rev-parse --abbrev-ref HEAD)"
		printf "vers:%s\\n" "$bvers" > $dest
		printf "build:%s\\n" "$binc" >> $dest
		printf "branch:%s\\n" "$branch" >> $dest
		printf "date:%s\\n" "$(date +%s)" >> $dest
	}
	function lux_gen_load(){
		src="${1:-$LUX_HOME}"
		[ -n "$2" ] && prefix='loaded' || prefix='script'; #hot or dry load
		dest="$src/build.id"
		if [ -f $dest ]; then
			while IFS='' read -r line || [[ -n "$line" ]]; do
				name="${prefix}_${line%%:*}"
				printf -v "$name" '%s' "${line#*:}"
			done < "$dest"
		fi
  }
	function lux_build_version(){
		lux_gen_load "$LUX_HOME"
		case $1 in
			www)
				if [ -n "$LUX_WWW" ]; then
					lux_gen_load "$LUX_WWW" true
					echo $loaded_build
				else
					echo "none"
				fi
			;;
			build) [ -n "$LUX_HOME" ] && echo "$script_build"|| echo "n/a";;
			vers)  [ -n "$LUX_HOME" ] && echo "$script_vers" || echo "n/a";;
			*)     [ -n "$LUX_HOME" ] && echo "$script_vers-$script_build" || echo "n/a";;
		esac
	}
	function lux_version(){
		lux_gen_load
		printf "$script_vers-$script_build"
	}
	function lux_mods(){
		LUX_MODS=($(find "$LUX_CORE" -type d -printf '%P\n' ))
	}
	function lux_need_align_repos(){
		trace "NEED ALIGN"
		[ -z "$LUX_WWW"  ] && missing+=( "$LUX_WWW" ) || :
		[ -z "$LUX_CLI"  ] && missing+=( "$LUX_CLI" ) || :
		[ -z "$LUX_DEV"  ] && missing+=( "$LUX_DEV" ) || :
		[ -z "$LUX_CSS"  ] && missing+=( "$LUX_CSS" ) || :
		[ -z "$LUX_HOME" ] && missing+=( "$LUX_HOME" ) || :
		len=${#missing[@]}
		dump "${missing[@]}"
		[ $len -gt 0 ] && return 0
		return 1
	}
	function lux_align_repos(){
		local this len buf arr want repo need
		buf=(${__alias_list[*]}); ret=$?
		len=${#buf[@]}
		want=(lux lux-cli lux-dev lux-www)
		missing=()
		if [ $len -gt 0 ]; then
			for i in ${!buf[@]}; do
				this="${buf[$i]}"
				repo="${__repo_list[$i]}"
				res=$(in_array "$this" "${want[@]}");ret=$?
				if [ $ret -eq 0 ]; then
					repo=${repo%/} #strip trail /
					case "$this" in
						lux-cli) LUX_CLI="$repo";;
						lux-www) LUX_WWW="$repo";;
						lux-dev) LUX_DEV="$repo";;
						lux) LUX_CSS="$repo"; LUX_HOME="$repo";;
						*) silly "found ?? ($this)";;
					esac
				else
					missing+=("Unfound:$this")
				fi
			done
			dump "${missing[@]}"
		else
			dump "${want[@]}"
		fi
	}
	function lux_find_repos(){
		local this len buf arr ndir
		this="$1"
		buf=($(find_dirs "git" "${this}/")); ret=$?
		len=${#buf[@]}
		if [ $len -gt 0 ]; then
			for this in ${buf[@]}; do
				arr=(${this//\// })
				len=${#arr[@]}
				ndir=${arr[((len-1))]}
				if [[ $ndir = *"lux"*  ]]; then
					__repo_list+=( $this )
					__alias_list+=( "$ndir" )
				fi
			done
			ret=0
		fi
		opt_dump_col="$blue"
		dump "${__repo_list[@]}"
		return $ret
	}
	function lux_listfile(){
		var=$1
		path=$2
		ftype=$3
		jsfile="$LUX_HOME/www/res/js/${var}.js"
		list=($(find "$LUX_HOME/www/${path}" -type f -name "*.${ftype}" ! -name '_*.*' -printf '%P\n' ))
		len=$((${#list[@]}-1));
		printf "%s\\n" "////found $(($len+1)) $ftype files" > $jsfile
		printf "%s\\n" "var ${var} = [" >> $jsfile
		for i in ${!list[@]}; do
			this="'${list[$i]}'"
			[ $i -lt $len ] && this="${this},"
			printf "%s\\n" "$this" >> $jsfile
		done
		printf "%s\\n" "];" >> $jsfile
	}
	function lux_genlist(){
		lux_gen_version
		info "Compiling file lists..."
		lux_listfile "js_list" "res/js" "js"
		lux_listfile "css_list" "res/css" "css"
		lux_listfile "html_list" "test" "html"
		lux_make_js
	}
	function lux_js_str(){
		data+=""
		data="$(cat <<-EOF
			//// lux generated javascript file
			const LUX_VERSION="$script_vers"
			const LUX_BUILD="$script_build"
			const LUX_BASIS="$opt_basis"
			const LUX_THEME="archxray"
			const LUX_TIMESTAMP="$script_date"
			////\n
		EOF
		)";
		echo "$data"
	}
	function lux_make_js(){
		info "Generating lux-meta.js file!"
		path="$LUX_RES/js"
		src="${1:-$LUX_META_JS}"
		js_str="$(lux_js_str)"
		echo -e "$js_str" > ${src}
		cat ${path}/js_list.js ${path}/css_list.js ${path}/html_list.js  >> ${src}
		rm ${path}/*list.js
	}
	function lux_rc_end_user_str(){
		data+=""
		data="$(cat <<-EOF
		EOF
		)";
		echo "$data"
	}
	function lux_rc_dev_user_str(){
		data+=""
		data="$(cat <<-EOF
			${line}
			### lux generated config file $(date)
			export BASH_USR_BIN="$BASH_USR_BIN"
			export LUX_DEVELOPER="$LUX_DEVELOPER"
			export LUX_HOME="$LUX_HOME"
			export LUX_DEV_BIN="$LUX_DEV_BIN" #cli/dev bin
			export LUX_BIN="$BASH_USR_BIN/qodeparty/lux" #install bin
			export LUX_RC="$LUX_RC"
			export LUX_STATUS=0
			export LUX_USER_CONF="$LUX_USER_CONF"
			export LUX_INSTALL_DIR="$LUX_INSTALL_DIR"
			export LUX_SEARCH_PATH="$LUX_SEARCH_PATH"
			export LUX_CLI="$LUX_CLI"
			export LUX_DEV="$LUX_DEV"
			export LUX_CSS="$LUX_CSS"
			export LUX_WWW="$LUX_WWW"
			__repo_list=(${__repo_list[*]})
			__alias_list=(${__alias_list[*]})
			if [ -n "\$BASH_USR_BIN" ]; then
				[[ ! "\$PATH" =~ "\$BASH_USR_BIN" ]]  && export PATH=\$PATH:\$BASH_USR_BIN;
			fi
			if [ -n "\$LUX_BIN" ]; then
				[[ ! "\$PATH" =~ "\$LUX_BIN" ]] && export PATH=\$PATH:\$LUX_BIN;
			fi
			if [ -n "\$LUX_DEV_BIN" ]; then
				[[ ! "\$PATH" =~ "\$LUX_DEV_BIN" ]] && export PATH=\$PATH:\$LUX_DEV_BIN;
			fi
			alias luxcd="cd \$LUX_HOME; ls -la; [ -t 1 ] && printf \"\n${blue}${lambda}Lux directory.${x}\n\"||:"
			alias luxwww="cd \$LUX_WWW; ls -la; [ -t 1 ] && printf \"\n${blue}${lambda}Lux WWW.${x}\n\"||:"
			alias luxdev='[ \$LUX_DEVELOPER -eq 0 ] && export LUX_DEVELOPER=1 || export LUX_DEVELOPER=0; lux rrc --quiet; echo \$LUX_DEVELOPER'
			alias luxup='[ \$LUX_DEVELOPER -eq 0 ] && luxbin cpub --quiet  && lux rrc --quiet && rr && luxdev >/dev/null && echo -e "$blue$lambda$x" || echo "Developer Mode required to publish Lux"'
			${line}
		EOF
		)";
		echo "$data"
	}
	function lux_make_rc(){
		local show src rc_str
		info "Saving .luxrc file..."
		src="${LUX_RC}"
		rc_str="$(lux_rc_dev_user_str)"
		echo -e "$rc_str" > ${src}
		[ $opt_dump -eq 0 ] || [ -n "$1" ] && lux_dump_rc || :
		unstat STATE_LUX_RC_FILE #kind of wantt his in the inc-checkup. not sure
		[ -f "${src}" ] && return 0 || return 1;
	}
	function lux_dump_rc(){
		if [ -f "$LUX_RC" ]; then
			echo $line${nl}
			cat "$LUX_RC"
		else
			warn "Lux RC doesnt exist. ($LUX_RC)"
		fi
	}
	function lux_load_rc(){
		[ -f "$LUX_RC" ] && info "Loading .luxrc file..." && source $LUX_RC && unstat STATE_LUX_RC_FILE || wtrace "Cant load Lux RC. Missing ($LUX_RC). "
	}
	function lux_reset_rc(){
		[ -f "$LUX_RC" ] && rm "$LUX_RC"
	}
	function lux_set_rc(){
		[ -f "$1" ] && LUX_RC="$1"
	}
	function dev_fast_clean(){
		if [[ "$script_entry" =~ "luxbin" ]]; then
			if [ $opt_dev_mode -eq 0 ]; then
				info "$ROOT_DIR/dist  $LUX_INSTALL_DIR  $ROOT_DIR/.luxrc"
				rm -rf "$ROOT_DIR/dist"
				rm -rf "$LUX_INSTALL_DIR"
				rm -f "$ROOT_DIR/.luxrc"
				profile_unlink #take rc out of profile
			else
				error "Fast clean requires [--dev] flag"
			fi
		else
			error "Fast clean can only be run using luxbin"
		fi
	}
##==============================================================================
## import file:inc-buildtools ##
##==============================================================================
	function lux_user_config(){
		local list this i
		info "Loading user config..."
		opt_debug=0
		if [ "$1" == "rm" ]; then
			warn "Clearing cached user config."
			LUX_USER_CONF=
			lux_make_rc
			return 0
		fi
	  list=( "$LUX_HOME/$1" "./conf/$1" "$HOME/$1" "$LUX_HOME/local-config.json" "./lux-config.json" "$HOME/lux-config.json" "$LUX_USER_CONF")
		for i in ${!list[@]}; do
			this="${list[$i]}"
			if [ -f "$this" ]; then
				 if [ "$this" != "$LUX_USER_CONF" ]; then
				 	 ptrace "New config file at $this"
				 	 LUX_USER_CONF=$this
				 	 lux_make_rc
				 else
				 	 warn "Found existing config file (${this//$LUX_HOME/.})."
				 fi
				 add_var "local_conf:true" "conf_path:$this"
				 break
			else
				 ftrace "Cant find a config file at ($this)$dots"
			fi
		done
	}
	function lux_res_mods(){
		local i css_path clean this this_file
		trace "Copy modules to res folder..."
		lux_mods
		css_path="$LUX_RES/css"
		clean=${1:-1}
		for i in ${!LUX_MODS[@]}; do
			this="${LUX_MODS[$i]}"
			this_file="${LUX_BUILD}/${this}.css"
			that_file="$css_path/lux-${this}.css"
			if [ $clean -eq 0 ]; then
				[ -f "$that_file" ] && rm -rf "$that_file" || :
			else
				[ -f "$this_file" ] && cp "$this_file" "$that_file"  || error "Didnt copy $this"
			fi
		done
		[ $clean -eq 0 ] && info "Cleaning (${LUX_MODS[*]}) styles" || trace "Copying (${LUX_MODS[*]}) styles";
	}
	function lux_prep(){
		local src data
		src="$1"
		data+=""
		data="$(cat <<-EOF
			/* $script_id $script_vers | $script_lic (c)2018 $script_author | https://qodeparty.com/get/lux */
		EOF
		)";
		printf '%s\n%s' "$data" "$(cat $src)" > $src
	}
	function lux_clean(){
		info "Cleaning... dist build res/build"
		[ -d $LUX_DIST ]  && rm -rf $LUX_DIST  || :
		[ -d $LUX_BUILD ] && rm -rf $LUX_BUILD || :
		[ -d $LUX_RBUILD ] && rm -rf $LUX_RBUILD || :
		[ -f $LUX_META_JS ] && rm $LUX_META_JS || :
		lux_res_mods 0
	}
	function lux_copy_res(){
		info "Copying build & dist to res..."
		mkdir -p "$LUX_RBUILD"
		[ -d "$LUX_BUILD" ] && cp $LUX_BUILD/*.css $LUX_RBUILD || error "Missing build directory, cant copy res"
		[ -d "$LUX_DIST"  ] && cp $LUX_DIST/*.css  $LUX_RBUILD || error "Missing dist directory, cant copy res"
	}
	function lux_copy_www(){
		local res ret
		info "Copying resouce and generated files to www..."
		if [ -d "$LUX_WWW" ]; then
			mkdir -p $LUX_WWW/res/build
			cp -r $LUX_RES $LUX_WWW
			cp -r $LUX_HOME/www/test $LUX_WWW
			cp -r $LUX_HOME/www/index.html $LUX_WWW
		else
			error "Problem copying build files"
		fi
	}
	function lux_push_www(){
		local res ret build_id www_id
		msg=${1:-gem}
		build_id="$(lux_build_version 'build')";
		www_id=$(date +%s)
		msg="auto build $build_id.$www_id :$msg:"
		info "Pushing automated build... <$msg>"
		res=$(cd $LUX_WWW; git add -A .;git commit -m "$msg"; git push origin; ); ret=$?
		__print "$res"
	}
	function lux_parse_styl(){
		local this="$1"
		if [ -n "$this" ]; then
			thisd=$(dirname $this)
			thisb=$(basename $thisd)
			thisf=$(basename $this)
			d="$thisb"
			f="${thisf//\.styl/}" #remove extension
			case $f in
				index)     p="${d}";;
				[a-zA-Z]*) p="${d}-${f}";;
				*) return 1;;
			esac
			echo "$p"
			return 0
		fi
		return 1
	}
	function lux_build_all(){
		info "Building All!"
		lux_mods
		lux_var_refresh
		lux_build_all_mods
		lux_build
		lux_copy_res
		
		lux_copy_www
	}
	function lux_compile(){
		local this thisd thisb thisf d f p buildtype
		this="$1"
		btype="$2"
		lux_mods
		if [ ${#this} -gt 0 ] && [ -f "$this" ]; then
			thisd=$(dirname $this)
			thisb=$(basename $thisd)
			thisf=$(basename $this)
			buildtype=${btype:-$(lux_buildtype $thisb)} #passed btype is type
			info "Compiling... ($thisb/$thisf) $buildtype"
			case $buildtype in
				main)
						silly "Rebuild main! ($thisb)"
						lux_build
					;;
				only)
						silly "Rebuild this only! ($thisb)"
						lux_build_submod "$this"
						lux_build_mod "debug"
					;;
				each)
						silly "Rebuild each! ($thisb)"
						lux_build_each
						lux_build
					;;
				mod)
						silly "Rebuild mod! ($thisb)"
						lux_build_submod "$this"
						lux_build
					;;
				*)
						silly "Woops!"
					;;
			esac
			lux_copy_res
			lux_res_mods
			lux_genlist
		fi
	}
	function lux_buildtype(){
		local mod mode val
		mod=$1
		mode=$2
		case $mod in
			core)  		 [ -z "$mode" ] && val='main' || val="$LUX_CORE";;
			util) 		 [ -z "$mode" ] && val='each' || val="$LUX_UTIL";;
			fx|mixins) [ -z "$mode" ] && val='each' || val="$LUX_UTIL/$mod";;
			vars)		   [ -z "$mode" ] && val='each' || val="$LUX_VARS";;
			*) 				 [ -z "$mode" ] && val='mod'  || val="$LUX_CORE/$mod";;
		esac
		echo $val;
	}
	function lux_build_path(){
		[ ! -d $LUX_BUILD ] && mkdir -p $LUX_BUILD
	}
	function lux_build(){
		info "Rebuilding Lux..."
		[ ! -d $LUX_DIST ] && mkdir -p $LUX_DIST
		touch "$LUX_DIST/lux.css" "$LUX_DIST/lux.min.css"
		[ -n "$opt_basis" ] && this_name="lux-$opt_basis" || this_name='lux'
		res=$(stylus $OPT_ALL -r "$LUX_CORE" --out "$LUX_DIST/$this_name.css"); ret=$?;
		status $ret "$res" "Compile Error"
		res=$(stylus -c $OPT_ALL -r "$LUX_CORE" --out "$LUX_DIST/$this_name.min.css");ret=$?;
		status $ret "$res" "Compile Error"
		lux_prep "$LUX_DIST/$this_name.css"
		lux_prep "$LUX_DIST/$this_name.min.css"
		lux_res_mods
		lux_genlist
	}
	function lux_build_each(){
		local files arr d i f j p err;
		info "Rebuilding each..."
		index='index.styl'
		files=();
		lux_mods
		arr=("${LUX_MODS[@]}");
		lux_build_path
		for i in ${!arr[@]}; do
			d="${arr[$i]}"
			this="$LUX_CORE/$d"
			[ -d "$this" ] && files=($(find $this -type f -name *.styl -printf "%f\n" )) || err="Invalid directory ($d)"
			if [ -z "$err" ]; then
				res=$(in_array "$index" "${files[@]}"); ret=$?
				if [ $ret -eq 0 ]; then
					files=($(pop_array "$index" "${files[@]}"))
					files+=("$index"); #move to end
				fi
				info "Files ($orange$d$x$blue)=> ${files[*]}"
				for j in ${!files[@]}; do
					f="${files[$j]//\.styl/}" #remove extension
					[ "$f" = "index" ] && p="${d}" || p="${d}-${f}";
					silly "Rebuilding ($d-$f) ..."
					stylus $OPT_ALL -r "$LUX_CORE/$d/${f}.styl" --out "$LUX_BUILD/${p}.css";ret=$?;
					status $ret "$res" "Compile Error"
				done
			else
				error "$err"
			fi
			err=
		done
		lux_res_mods
		lux_genlist
	}
	function with_basis(){
		local this_name
		[[ "$2" =~ $1 ]] &&	[ -n "$opt_basis" ] && this_name="$2-$opt_basis" || this_name="$2"
		echo $this_name
	}
	function lux_build_submod(){
		local this name res ret;
		this="$1"
		name=$(lux_parse_styl $this); ret=$?
		[[ "$name" =~ "flex" ]]
		if [ $ret -eq 0 ]; then
			lux_build_path
			if in_string '-' "$name"; then
				info "[SUB] Rebuilding Sub... ${name}.css"
				res=$(stylus $OPT_ALL "$this" --out "$LUX_BUILD/${name}.css"); ret=$?;
				status $ret "$res" "Compile Error"
				rm -f "$LUX_RBUILD/${name}.css"
				cp "$LUX_BUILD/${name}.css" "$LUX_RBUILD/${name}.css"
				bname=$(with_basis "flex" "$name")
				if [[ "$bname" != "$name" ]]; then
					cp "$LUX_BUILD/${name}.css" "$LUX_BUILD/${bname}.css"
					cp "$LUX_BUILD/${name}.css" "$LUX_RBUILD/${bname}.css"
				fi
			fi
			lux_build_mod "${name%%\-*}"
		else
			error "Problem building $this";
		fi
	}
	function lux_build_all_mods(){
		for i in ${!LUX_MODS[@]}; do
			this="${LUX_MODS[$i]}"
			lux_build_mod "$this"
		done
	}
	function lux_build_mod(){
		local res ret mod modpath;
		mod="$1"
		res=$(in_array "$mod" "${LUX_MODS[@]}"); ret=$?;
		if [ $ret -eq 0 ]; then
			lux_build_path
			modpath=$(lux_buildtype $mod true)
			if [ -d $modpath ]; then
				info "[MOD] Rebuilding... ${mod}.css"
				res=$(stylus $OPT_ALL "${modpath}/index.styl" --out "$LUX_BUILD/${mod}.css");
				status $ret "$res" "Compile Error"
				rm -f "$LUX_RBUILD/${mod}.css"
				cp "$LUX_BUILD/${mod}.css" "$LUX_RBUILD/${mod}.css"
				bname=$(with_basis "layout" "$mod")
				if [[ "$bname" != "$mod" ]]; then
					cp "$LUX_BUILD/${mod}.css" "$LUX_BUILD/${bname}.css"
					cp "$LUX_BUILD/${mod}.css" "$LUX_RBUILD/${bname}.css"
				fi
			else
				error "Invalid module directory ($mod)";
			fi
		else
			error "Unknown module ($mod)";
		fi
	}
	function lux_watch(){
		local IFS sec chsum1 chsum2 chval res this;
		sec="${1:-5}"
		only="$2"
		chsum1=""; opt_debug=0
		__print "\n\n\n$line"
		info "Watching ./src ..." # $diff_time"
		while [[ true ]];
		do
			chsum2=`find $LUX_HOME/src -type f \( -name "*.styl" -o -name "*.css*" -o -name "*.js*" \) -mmin -0.3 -exec md5sum {}  \;`
			if [[ $chsum1 != $chsum2 ]] ; then
				res=$(echo "$chsum2")
				IFS=' ' read -r -a array <<< "$res"
				this="${array[1]}"
				info "${array[0]}";
				[ ${#this} -gt 0 ] && warn "Change detected... <${this}>";
				[[ "$this" =~ ".styl" ]] && res=$(lux_compile "$this") && ret=$? || ret=1;
				[[ "$this" =~ ".js" ]]   && res=$(lux_compile "$LUX_UTIL/index.styl") || :
				chsum1=$chsum2
				chval="${chsum2%% *}"
				if [ $ret -eq 0 ]; then
					[ -n "$chval" ] && pass "${green}Watch job ($orange$chval$green) completed!$x$nl$line" || :
				fi
			fi
			sleep 1
		done
	}
	function lux_watch_only(){
		local IFS  chsum1 chsum2 chval res this;
		only="$1"
		count=0
		__print "\n\n\n$line"
		info "Watching ./src $only ..."
		chsum1=""; opt_debug=0
		if [ -n "$only" ]; then
			while [[ true ]];
			do
				chsum2=`find $LUX_HOME/src/styl -type f \( -name "$only" \) -mmin -1 -exec md5sum {}  \;`
				if [[ $chsum1 != $chsum2 ]] ; then
					this="${chsum2#*  }" #not sure why this is two spaces!!?
					[[ "$this" =~ ".styl" ]] && res=$(lux_compile "$this" "only") && ret=$? || ret=1;
					chsum1=$chsum2
					chval="${chsum2%% *}"
					if [ $ret -eq 0 ]; then
						count=$(($count+1));
						[ -n "$chval" ] && success "Watch job ($count) completed!" "$orange$chval$green" || :
					else
						error "Job cancelled due to error! Restarting..."
						info "Watching ./src $only [$count]\n\n\n"
					fi
				fi
			sleep 1
			done
		else
			fail "Watch failed, missing filename"
		fi
	}
	function search_replace_bash(){
		target="$1"
		no_comments="$2"
		res=($(grep -E '^[[:space:]]*include' $target -n | awk '{print $1 $3}'))
		lines=()
		files=()
		real=()
		tmp_target="${target}.copy"
		cp "$target" "$tmp_target"
		for i in ${!res[@]}; do
			this=${res[$i]}
			file_ref=${this##*:}
			line_no=${this%%:*}
			lines+=("$line_no")
			files+=("$file_ref")
			real_file=$(eval echo "$file_ref")
			real+=("$real_file")
		done
		for i in ${!lines[@]}; do
			this=${lines[$i]}
			ref=${files[$i]}
			val=${real[$i]}
			qref=$(quoteRe "include $ref")
			insert_wh_replace "$val" "$tmp_target" "$qref"
			name=$(basename $ref)
			data="$bline\n## import file:${name%%\.sh*} ##\n$bline"
			sed -i.bak -e "s|.*${qref}.*|${data}|i" $tmp_target
			if [ -z "$no_comments" ]; then
				qref=$(quoteRe "#!")
			else
				qref=$(quoteRe "#")
				qref="^[[:space:]]*${qref}[^#]"
			fi
			sed -i.bak -e "15,\${ /${qref}/d }" "$tmp_target"
		done
		sed -i.bak "/^$/d" "$tmp_target"
		echo "$tmp_target"
	}
	function make_cli_dist(){
		build="$(cd $ROOT_DIR && git rev-list HEAD --count).$(date +%s)"
		wtrace "Lux CLI Dist build is $build"
		src_file="${1:-$ROOT_DIR/src/bash/luxbin}" #this is where main template
		tmp_file=$(search_replace_bash "$src_file" "$2")
		dist_file="$ROOT_DIR/dist/lux"
		mkdir -p "$ROOT_DIR/dist"
		mv "$tmp_file" "$dist_file"
		[ -f "$tmp_file.bak" ] && rm "$tmp_file.bak"
		echo $build
	}
	function deploy_dist_home(){
    dist_file="$ROOT_DIR/dist/lux"
    if [ -d "$LUX_HOME" ]; then
	    target="$LUX_HOME/bin"
	    if [ -f "$dist_file" ]; then
		    mkdir -p "$target"
		    cp "$dist_file" "$target/lux"
		    return 0
		  fi
		fi
		return 1
	}
##==============================================================================
## import file:inc-checkup ##
##==============================================================================
	status_err=()
	err_vals=()
	status_pass=()
	pass_vals=()
	state_config=()  #STATE_CONFIG_READY
	state_install=() #STATE_INSTALL_READY
	state_build=()   #STATE_BUILD_READY
	state_publish=() #STATE_PUBLISH_READY
	function is_error(){
		[ -z "$1" ] && return 1 || :
		res=$(in_array "$1" "${status_err[@]}");ret=$?
		return $ret
	}
	function unstat(){
		local val="-$1"; shift;
		local list=(${status_err[@]})
		wtrace "Unsetting status [$val]"
		val=$(upd_array "$val" "${list[@]}")
		status_err=($val)
	}
	function dump_results(){
		trace "$bline"
		opt_dump_col="$orange"
		dump "${status_err[@]}"
		opt_dump_col="$blue"
		dump "${status_pass[@]}"
	}
	function __env_repair(){
		trace "---env_repair"
		local arr=(${@})
		local len=${#arr[@]}
		if [ $len -gt 0 ]; then
			for i in ${!arr[@]}; do
				local this="${arr[$i]}"
				declare -F "${!this}" &> /dev/null
				ret=$?
				if [ $ret -eq 0 ]; then
					${!this};
					ret=$?
					sleep .02
					log "$(res $ret) Fixed ($this)?"
				else
				 log "$(res $ret) No FX for ($this)"
				fi
			done
		fi
		return 0
	}
	function lux_checkup(){
		silly "Check Setup!"
		unset status_err
		unset err_vals
		unset status_pass
		unset pass_vals
		check_each_state 0
		lux_auto_repair
		check_each_state 1
	}
	function lux_repair(){
		lux_checkup
		silly "Lux Repairing..."
		lux_pre_config
		lux_pre_config_cli
		lux_pre_config_bash_prof
		lux_pre_config_lux_home
		lux_pre_config_set_homevars
		lux_pre_config_rc_file
		lux_pre_config_bin_dir
		lux_pre_install
		lux_want_install
		lux_make_rc
		len=${#status_err[@]}
		if [ $len -gt 0 ]; then
			error "Completed with errors"
			dump_results
		else
			info "WELP! ($len)s"
		fi
	}
	function lux_auto_repair(){
		lux_pre_config_cli
		lux_pre_config_bash_prof
		lux_pre_config_lux_home
		lux_pre_config_set_homevars
		lux_pre_config_rc_file
		lux_pre_config_bin_dir
		lux_pre_install
		lux_want_install
	}
	function check_each_state(){
		test_only="${1:-1}"
		[ $test_only -eq 0 ] && dtrace "TEST ONLY"
		status_err=()
		err_vals=()
		status_pass=()
		pass_vals=()
		assert_defined  LUX_DEV_BIN    STATE_LUX_DBIN_DEF   ;
		assert_inpath   LUX_DEV_BIN		 STATE_LUX_DBIN_PATH	;
		assert_defined  BASH_PROFILE   STATE_BASH_PROF_DEF  ;
		assert_defined  BASH_RC        STATE_BASH_RC_DEF    ;
		assert_defined  LUX_RC         STATE_LUX_RC_DEF     ;
		assert_file     LUX_RC         STATE_LUX_RC_FILE    ;
		assert_defined  LUX_HOME  		 STATE_LUX_HOME_DEF   ;
		assert_dir      LUX_HOME  		 STATE_LUX_HOME_DIR   ;
		assert_defined  LUX_BUILD      STATE_LUX_BUILD_DEF  ;
		assert_defined  LUX_DIST   	   STATE_LUX_DIST_DEF   ;
		assert_defined  LUX_SEARCH_PATH  STATE_LUX_SRC_DEF  ;
		assert_defined  LUX_CLI         STATE_LUX_CLI_DEF    ;
		assert_dir      LUX_CLI         STATE_LUX_CLI_DIR    ;
		assert_defined  BASH_USR_BIN    STATE_BASH_UBIN_DEF ;
		assert_inpath   BASH_USR_BIN    STATE_BASH_UBIN_PATH;
		assert_dir      BASH_USR_BIN    STATE_BASH_UBIN_DIR ;
		assert_defined  LUX_INSTALL_DIR  STATE_LUX_INST_DEF ;
		assert_writable LUX_INSTALL_DIR  STATE_LUX_INST_WRITE;
		assert_defined  LUX_INSTALL_BIN  STATE_LUX_IBIN_DEF;
		assert_file 		LUX_INSTALL_BIN  STATE_LUX_IBIN_FILE;
		assert_link      BASH_PROFILE STATE_BASH_PROF_LINK;
	}
	function assertion_type(){
		local code ret
		code="$1"
		ret="$2"
		case "$1" in
			*DEF*) this_atype="var"
				[ $ret -eq 0 ] && this_res="${blue}def$x";
				[ $ret -eq 1 ] && this_res="undef";
				;;
			*PATH*) this_atype='path'
				[ $ret -eq 0 ] && this_res="${blue}inpath$x";
				[ $ret -eq 1 ] && this_res="ninpath";
				;;
			*FILE*) this_atype='file'
				[ $ret -eq 0 ] && this_res="${blue}exists$x";
				[ $ret -eq 1 ] && this_res="dne";
				;;
			*LINK*) this_atype='link'
				[ $ret -eq 0 ] && this_res="${blue}linked$x";
				[ $ret -eq 1 ] && this_res="nlk";
				;;
			*DIR*) this_atype='dir'
				[ $ret -eq 0 ] && this_res="${blue}exists$x";
				[ $ret -eq 1 ] && this_res="dne";
				;;
			*WRITE*) this_atype='write'
				[ $ret -eq 0 ] && this_res="${blue}writable$x";
				[ $ret -eq 1 ] && this_res="nwa";
				;;
			*) this_atype='unk';;
		esac
	}
	function record_assertion(){
		local ret val st val name
		ret=$1;param=${!2}; st=$3; val="$4" name=$2;
		[ $ret -eq 1 ] && { status_err+=( "$st" ); err_vals+=( "$name" ); } ||
											{ status_pass+=( "$st" ); pass_vals+=( "$name:${val:-$param}" ); }
		assertion_type $st $ret
		if [ $test_only -eq 1 ]; then
			[[ ! "$this_atype" =~ "var" ]]  && param="$this_res";
			[ $ret -eq 1 ] && param="$grey2--$x" || :
			[ $ret -eq 1 ] && this_stat="${fail} Fail$x" || this_stat="${pass} Pass$x"
			printf -v "out" "| %-5s | %-5s | \$%-20s | %-60s $x$eol" "${this_stat}" "$this_atype" "$name" "$param"
			__print "$out"
		fi
	}
	function assert_defined(){
		local ret this; this=${!1};
		[ -z "$this" ] && ret=1 || ret=0; record_assertion $ret "$1" "$2"
		return $ret
	}
	function assert_file(){
		local ret this; this=${!1};
		[ ! -f "$this" ] && ret=1 || ret=0; record_assertion $ret "$1" "$2" true
		return $ret
	}
	function assert_dir(){
		local ret this; this=${!1};
		if [ -n "$this" ]; then
		 [ ! -d "$this" ] && ret=1 || ret=0;
		else
			ret=1
		fi
		record_assertion $ret "$1" "$2" true
		return $ret
	}
	function assert_inpath(){
		local ret this; this=${!1};
		if [ -n "$this" ]; then
		 [[ ! "$PATH" =~ "$this" ]] && ret=1 || ret=0;
		else
			ret=1
		fi
		record_assertion $ret "$1" "$2" true
		return $ret
	}
	function assert_writable(){
		local ret this; this=${!1};
		if [ -n "$this" ]; then
			[ ! -w "$this" ] && ret=1 || ret=0;
		else
			ret=1
		fi
		record_assertion $ret "$1" "$2" truealias
		return $ret
	}
	function assert_link(){
		local this=$1
		:
	}
	function assert_infile(){
		local this=$1
		:
	}
	function assert_ready(){
		local this=$1
		:
	}
	function repair_home(){
		LUX_HOME="$1"
		lux_pre_config_set_homevars
		[ -d "$LUX_HOME" ] && unstat STATE_LUX_HOME_DEF || :
		dtrace "Repaired LUX Home ($LUX_HOME)"
	}
	function repair_binvars(){
		trace "try Resolve STATE_BASH_UBIN_DEF-(Sub Dirs)"
		BASH_USR_BIN="$1"
		if [ -n "$BASH_USR_BIN" ]; then
			QODEPARTY_INSTALL_DIR="$BASH_USR_BIN/qodeparty"
			LUX_INSTALL_DIR="$QODEPARTY_INSTALL_DIR/lux"
			LUX_INSTALL_BIN="$LUX_INSTALL_DIR/lux"
			dtrace "Repair BINVARS unsets"
			[ -n "$LUX_INSTALL_DIR" ] && [ -d "$LUX_INSTALL_DIR" ] && unstat STATE_LUX_INST_DEF || :
			[ -n "$LUX_INSTALL_BIN" ] && [ -f "$LUX_INSTALL_BIN" ] && { unstat STATE_LUX_IBIN_DEF; unstat STATE_LUX_IBIN_FILE; } || :
		else
			: #printf "Lux home not defined $LUX_HOME \n"
		fi
	}
	function repair_install_dir(){
		:
	}
	function prompt_home(){
		if confirm "${lambda} ${blue}LUX_HOME$x is not set. Set the location manually (y/n)"; then
			res=$(prompt_path "Where is \${blue}LUX_HOME\$x directory on \$blue\$HOSTNAME\$x" "Is this correct" "$LUX_HOME");ret=$?
			LUX_HOME="$res"
		else
			:
		fi
	}
	function prompt_repos(){
		local res ret next
		if [ -z "$LUX_SEARCH_PATH" ]; then
			wtrace "Lux search path missing${x}"
			if confirm "${x}Do you want to run repo finder (y/n)"; then
				  sleep 0.2
					res=$(prompt_path "Where should Lux search for Repos ex: \$blue\$default\$x" "Search for Lux repos in" "$HOME/src");ret=$?
					[ $ret -eq 1 ] && return 1;
					lux_need_align_repos;ret=$?
					if [ $ret -eq 0 ]; then
							if [ -d "$res" ]; then
								pass "Found search path $res" #"$ret"
								lux_find_repos "$res"; ret=$?
								[ $ret -eq 0 ] && LUX_SEARCH_PATH="$res" || :
								dtrace "Search path was $res $LUX_SEARCH_PATH ($ret)"
								lux_align_repos;
							else
							  fatal "Unable to find search path -> $res"
							fi
					fi
				return 0
			else
				return 1
			fi
			lux_need_align_repos;ret=$?
			res="$LUX_SEARCH_PATH"
			if [ $ret -eq 0 ]; then
					if [ -d "$res" ]; then
						pass "Found search path $res" #"$ret"
						lux_find_repos "$res"; ret=$?
						[ $ret -eq 0 ] && LUX_SEARCH_PATH="$res" || :
						lux_align_repos;
					else
					  fatal "Unable to find search path -> $res"
					fi
			fi
		fi
		return 0
	}
	function lux_pre_config(){
		trace "try Resolve STATE_DBIN_PATH"
		if is_error STATE_DBIN_PATH; then
			warn "Please run config again!"
		else
			: #pptrace "found DEV_BIN"
		fi
	}
	function lux_pre_config_cli(){
		trace "try Resolve STATE_LUX_CLI_DEF"
		if is_error STATE_LUX_CLI_DEF; then
			if [ -n "$LUX_CONFIG_HOME" ]; then
				LUX_CLI="$LUX_CONFIG_HOME"
				unstat STATE_LUX_CLI_DEF
			fi
		else
			: #pptrace "found CLI_DEF ($LUX_CONFIG_HOME)"
		fi
	}
	function lux_pre_config_bash_prof(){
		trace "try Resolve STATE_BASH_PROF_DEF"
		if is_error STATE_BASH_PROF_DEF; then
			warn "Prompt User for PROFILE or RC"
		else
			ptrace  "[SKIP]# Not implemented yet (STATE_BASH_PROF_DEF)"
		fi
	}
	function lux_pre_config_search_path(){
		trace "try Resolve STATE_LUX_SRC_DEF"
		if [ -z "$LUX_SEARCH_PATH" ]; then
			if [ $opt_skip_input -eq 1 ]; then
				prompt_repos "$LUX_HOME";ret=$?
				[ $ret -eq 0 ] && unstat STATE_LUX_SRC_DEF || :
			else
				wtrace "No User Input for LUX_SEARCH_PATH"
			fi
		fi
	}
	function lux_pre_config_lux_home(){
		trace "try Resolve STATE_LUX_HOME_DEF"
		if is_error STATE_LUX_HOME_DEF; then
			if [ -n "$LUX_CSS" ]; then
				LUX_HOME="$LUX_CSS"
			else
				lux_pre_config_search_path
			fi
			if [ -d "$LUX_HOME" ]; then
				repair_home "$LUX_HOME"
			else
				wtrace "Cant find Lux Home"
				prompt_home
			  [ $opt_skip_input -eq 1 ] && lux_make_rc || :
			fi
			
		else
			: #dtrace "found LUX Home ($LUX_HOME)"
		fi
		trace "try Resolve STATE_LUX_HOME_DIR"
		if is_error STATE_LUX_HOME_DEF; then
			if [ -n "$LUX_HOME" ]; then
				: #in this case the dir doesnt exist but the var does oops
			else
				: #even the var doesnt exist here so um
			fi
		fi
	}
	function lux_pre_config_rc_file(){
		trace "try Resolve STATE_LUX_RC_FILE"
		if is_error STATE_LUX_RC_FILE; then
			warn "RC Files requires PROFILE"
			[ $opt_skip_input -eq 1 ] && lux_make_rc || :
		else
			: #pptrace "found LUX_RC"
		fi
	}
	function lux_pre_config_set_homevars(){
		trace "try Resolve STATE_LUX_BUILD_DEF"
		trace "try Resolve STATE_LUX_DIST_DEF"
		if [ -n "$LUX_HOME" ]; then
			THIS_ROOT="$(dirname $LUX_HOME)"
			LUX_BUILD="$LUX_HOME/build"
			LUX_DIST="$LUX_HOME/dist"
			LUX_RES="$LUX_HOME/www/res"
			LUX_RBUILD="$LUX_RES/build"
			LUX_INST=1
			LUX_LIB="$LUX_HOME/src/lib"
			LUX_EXT="$LUX_LIB/plugin"
			LUX_DEFS="$LUX_LIB/defs"
			LUX_CORE="$LUX_HOME/src/styl/core"
			LUX_VARS="$LUX_HOME/src/styl/vars"
			LUX_UTIL="$LUX_HOME/src/styl/util"
			LUX_META_JS="$LUX_RES/js/lux-meta.js"
			OPT_INCLUDE="--include $LUX_EXT --include $LUX_UTIL --include $LUX_VARS --include $LUX_CORE"
			OPT_IMPORT="--import $LUX_UTIL --import $LUX_VARS " #order matters
			OPT_USE="" #update with lux_var_refresh
			OPT_ALL="" #update with lux_var_refresh
			unstat STATE_LUX_BUILD_DEF
			unstat STATE_LUX_DIST_DEF
		else
			: #printf "Lux home not defined $LUX_HOME \n"
		fi
	}
	function lux_pre_config_bin_dir(){
		trace "try Resolve STATE_BASH_UBIN_DEF"
		if is_error STATE_BASH_UBIN_DEF; then
				info "Error STATE UBIN"
				vars=( BASH_USR_BIN MY_BIN HOME_BIN USR_BIN QODE_BIN BIN)
				for this in ${vars[@]}; do
					: #dtrace "TRY $this => ${!this}" #devmode trace
					if [ -n "${!this}" ]; then
					  BASH_USR_BIN="${!this}"
					  repair_binvars "$BASH_USR_BIN"
					  break;
					fi
				done
				if [ -z "$BASH_USR_BIN" ]; then
					res=$(prompt_path "Cant find a default BIN directory var. What bin path to use (ex:\$HOME/bin) " "Set your home bin to")
					BASH_USR_BIN="$res"
					repair_binvars "$BASH_USR_BIN"
				fi
				unstat STATE_BASH_UBIN_DEF
		else
			: #ptrace "found BASH_USR_BIN ($BASH_USR_BIN) ??"
		fi
		trace "try Resolve STATE_BASH_UBIN_PATH"
		if is_error STATE_BASH_UBIN_PATH; then
			wtrace "PATH missing home bin, create rc file or set env var"
		else
			ptrace "[SKIP] # Not implemented (STATE_BASH_UBIN_PATH)"
		fi
		trace "try Resolve STATE_BASH_UBIN_DIR"
		if is_error STATE_BASH_UBIN_DIR; then
			[ ! -d "$BASH_USR_BIN" ] && mkdir -P "$BASH_USR_BIN" || :
			[ -d "$BASH_USR_BIN" ] && unstat STATE_BASH_UBIN_DIR || :
		else
			: #ptrace "# Not implemented (STATE_BASH_UBIN_DIR)"
		fi
	}
	function lux_pre_install(){
		trace "try Resolve STATE_LUX_INST_DEF"
		if is_error STATE_LUX_INST_DEF; then
			if [ -z "$LUX_INSTALL_BIN" ]; then
				if [  -n "$BASH_USR_BIN" ]; then
					repair_binvars "$BASH_USR_BIN"
				fi
			fi
			if [ -z "$QODEPARTY_INSTALL_DIR" ] || [ -z "$LUX_INSTALL_DIR" ]; then
				wtrace "Missing Dirs"
			fi
		else
			: #ptrace "#"
		fi
		trace "try Resolve STATE_LUX_INST_WRITE"
		if is_error STATE_LUX_INST_WRITE; then
			if [ $opt_skip_input -eq 1 ]; then
				if [ -n "$LUX_INSTALL_DIR" ]; then
					mkdir -p "$LUX_INSTALL_DIR"
					if [ ! -d "$LUX_INSTALL_DIR" ]; then
						wtrace "Cant write to or create bin install dir"
					else
						unstat STATE_LUX_INST_WRITE
					fi
				fi
			else
				: #skip input should we prompt?
			fi
		else
			: #ptrace "#"
		fi
	}
	function lux_want_dist(){
		:
	}
	function lux_want_install(){
		trace "try Resolve STATE_LUX_IBIN_DEF"
		if is_error STATE_LUX_IBIN_DEF; then
			if [ -z "$LUX_INSTALL_BIN" ]; then
				if [  -n "$BASH_USR_BIN" ]; then
					repair_binvars "$BASH_USR_BIN"
				fi
			fi
			if [ -n "$LUX_INSTALL_BIN" ]; then
				unstat STATE_LUX_IBIN_DEF;
			fi
		fi
		trace "try Resolve STATE_LUX_IBIN_FILE"
		if is_error STATE_LUX_IBIN_FILE; then
			if [ ! -f "$LUX_INSTALL_BIN" ]; then
				if [ -n "$LUX_DEV_BIN" ]; then
					this_exec="$LUX_DEV_BIN/luxbin"
					this_dist="$ROOT_DIR/dist/lux"
				fi
				if [ ! -f "$this_dist" ]; then
					wtrace "Distributable not found at $this_dist"
					if [ -n "$this_exec" ] && [ -f "$this_exec" ]; then
							if [[ "$script_entry" =~ "luxbin" ]]; then
								if [ $opt_skip_input -eq 1 ]; then
									opt_debug=0;
									make_cli_dist "$this_exec" "nocomments"
								else
									: #skip input -- prompt?
								fi
							else
								error "Cant compile lux from compiled lux! hehe nice try though! use <luxbin>"
							fi
					else
					 	error "Cant find luxbin executable! Probably deleted or not installed"
					fi
				fi
				if [ -f "$this_dist" ]; then
					if [ $opt_skip_input -eq 1 ]; then
						[ -f "$LUX_INSTALL_BIN" ] && cp "$LUX_INSTALL_BIN" "${LUX_INSTALL_BIN}.bak" || :
						cp "$this_dist" "$LUX_INSTALL_BIN"
					else
						: #skip -- prompt?
					fi
				else
					warn "Unable to find dist file at $dist_file"
				fi
				if [ $opt_skip_input -eq 1 ]; then
					if [ ! -f "$LUX_INSTALL_BIN" ]; then
						error "Repair Failed! Cannot build and install lux exec ($LUX_INSTALL_BIN)"
					else
						unstat STATE_LUX_IBIN_FILE;
					fi
				fi
			fi
		else
			if [ -f "$LUX_INSTALL_BIN" ]; then
				dtrace "Already have LUX IBIN ($LUX_INSTALL_BIN)";
				unstat STATE_LUX_IBIN_FILE;
				dtrace "Final bin check!"
			fi
		fi
	}
##==============================================================================
## import file:inc-api ##
##==============================================================================
function lux_make_www(){
	opt_debug=0;
	case $1 in
		push) shift; lux_copy_www; lux_push_www "$1";;
		*)    lux_copy_www "$1";;
	esac
}
function lux_make_cli(){
	require_entry "Cant compile lux from compiled lux! hehe nice try though ($script_entry)"
	opt_debug=0;
	make_cli_dist "$1" "nocomments"
}
function lux_search_files(){
	IFS=
	flags="-HiREl"
	case $1 in
		files) shift; res=$(grep -HiREl --color=always "$1" .);;
		html) shift; res=$(grep -HiRE --include=\*.html --color=always "$1" .);;
		styl) shift; res=$(grep -HiRE --include=\*.styl --color=always "$1" .);;
		*) res=$(grep -HiREn --color=always "$1" .);;
	esac
	echo "$res"
}
function lux_publish_dist(){
	require_entry "Cant publish lux from compiled lux! the universe will collapse! ($script_entry)"
	if [ -n "$LUX_DEV_BIN" ] && [ -n "$LUX_INSTALL_DIR" ]; then
		LUX_INSTALL_BIN="$LUX_INSTALL_DIR/lux"
		this_exec="$LUX_DEV_BIN/luxbin"
		this_dist="$ROOT_DIR/dist/lux"
		[ -f "$LUX_INSTALL_BIN" ] && cp "$LUX_INSTALL_BIN" "${LUX_INSTALL_BIN}.bak" || :
		cp "$this_dist" "$LUX_INSTALL_BIN"
		info "Publishing dist to $LUX_INSTALL_BIN"
		echo "$this_dist || $LUX_INSTALL_DIR || $LUX_INSTALL_BIN"
	else
		: #error
		error "Failed publishing! Lux not installed yet ($LUX_INST)"
	fi
}
function lux_publish_lux(){
	deploy_dist_home
}
##==============================================================================
## import file:inc-dispatch ##
##==============================================================================
	function dispatch(){
		local call ret
		skip=1
		lux_load_rc
		if [ $opt_local_conf -eq 0 ]; then
			lux_user_config 'local-conf.json'
		fi
		if [ -f "$LUX_USER_CONF" ]; then
			add_var "local_conf:true" "conf_path:$LUX_USER_CONF"
		fi
		lux_var_refresh
		for call in "$@"; do
			shift
			if [ $skip -eq 0 ]; then
				skip=1; continue
			fi
			case $call in
				ch*)      opt_skip_input=0; lux_checkup; ret=$?;;
				rep*)     opt_skip_input=1; lux_repair; ret=$?;;
				fc)       dev_fast_clean;;
				cpub*)    lux_make_cli && lux_publish_dist;;
				cdist)    lux_publish_dist;	break;;
				cphome)   lux_make_cli &&	lux_publish_lux;;
				link)     profile_link;    ret=$?;;
				unlink)   profile_unlink;  ret=$?;;
				find)     lux_search_files; break;;
				rc)       lux_dump_rc;     ret=$?;;
				rrc*)     lux_make_rc;     ret=$?;;
				json)
					add_var "test:1" "eat:candy"
					lux_var_refresh
					json_maker
					shift;;
				home)     quiet 0; echo -e "$LUX_HOME";;
				bin)      quiet 0; echo -e "$LUX_BIN";;
				cli)      quiet 0; echo -e "$LUX_CLI";;
				mods)     quiet 0; echo -e "${LUX_MODS[*]}";;
				self)     quiet 0; echo -e "$0";;
				here)     quiet 0; echo -e "$BIN_DIR";;
				rmods)    lux_res_mods;;
				list)     lux_genlist;;
				lconf)    lux_user_config 'local-conf.json';;
				watch)    lux_watch "$1"; shift;;
				only)     lux_watch_only "$1"; shift;;
				clean)    lux_clean ;;
				build|make)
					case $1 in
						each) shift; lux_build_each;;
						all)  shift; lux_build_all;;
						"")   shift; lux_build;;
						*)    lux_build_mod "$1";;
					esac
					break;
				;;
				www)    lux_make_www;;
				a|all)  lux_build_all;;
				each)   lux_build_each;;
				res)    lux_copy_res;;
				vars)   lux_vars;;
				gvers)  lux_gen_version;;
				vers*)
					opt_quiet=0
					lux_version
					exit 0
				;;
				\?|help)   lux_usage;;
				skip)   break;;
				\.)     break;;
				--*)    break;;
				*)
					if [ ! -z "$call" ]; then
						fatal "Invalid command" $call;
						lux_usage;  ret=1
					fi
				;;
			esac
		done
		return $ret
	}
	function main(){
		[ -f "$LUX_RC" ] && source $LUX_RC || : #wtrace "Lux RC is missing. "
		dispatch "$@"
	}
if [ "$0" = "-bash" ]; then
	:
else
	args=("${@}")
	args=( "${args[@]/\-*}" ); #delete anything that looks like an option
	main "${args[@]}";ret=$?
fi
